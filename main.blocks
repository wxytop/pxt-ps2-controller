<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="VoOHqFKNxu$9:WYD-rk`" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="{iZX^@f{a(o)SVA$r#hI" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace ps2controller {" line1="" line2="    let chipSelect = 0" line3="    let pad = pins.createBuffer(6)" line4="    let connected = false" line5="" line6="    /*" line7="    // Unused at the moment" line8="    const config_cmd_enter = hex" line9="        `014300010000000000`" line10="    const config_cmd_exit = hex" line11="        `014300005a5a5a5a5a`" line12="    const config_enable_analog = hex" line13="        `014400010300000000`" line14="    const config_enable_vibration = hex" line15="        `014d000001ffffffff`" line16="    */" line17="" line18="    //" line19="    const poll_cmd = hex" line20="        `014200000000000000`" line21="" line22="" line23="    /**" line24="     * initstall PS2 Receiver Pin" line25="     * @param CLKPin SCK Pin; eg: DigitalPin.P13" line26="     * @param DATPin MISO Pin; eg: DigitalPin.P14" line27="     * @param CMDPin MOSI Pin; eg: DigitalPin.P15" line28="     * @param CSPin  CS Pin; eg: DigitalPin.P16" line29="     */" line30="    //% blockId=ps2_init_pin block=&quot;PS2PIN CLK|%CLK|DAT|%DAT|CMD|%CMD|CS %CS&quot;" line31="    //% weight=100" line32="    //% inlineInputMode=inline" line33="    export function initPS2Pin(CLKPin: DigitalPin, DATPin: DigitalPin, CMDPin: DigitalPin, CSPin: DigitalPin) {" line34="        chipSelect = CSPin" line35="        pins.digitalWritePin(chipSelect, 1)" line36="        pins.spiPins(CMDPin, DATPin, CLKPin)" line37="" line38="        // chipSelect = DigitalPin.P15" line39="        // pins.digitalWritePin(chipSelect, 1)" line40="        // pins.spiPins(DigitalPin.P14, DigitalPin.P13, DigitalPin.P16)" line41="" line42="        pins.spiFormat(8, 3)" line43="        pins.spiFrequency(250000)" line44="    }" line45="" line46="    function send_command(transmit: Buffer): Buffer {" line47="        // deal with bit-order" line48="        transmit = rbuffer(transmit)" line49="" line50="        let receive = pins.createBuffer(transmit.length);" line51="" line52="        pins.digitalWritePin(chipSelect, 0);" line53="        // send actual command" line54="        for (let i = 0; i &lt; transmit.length; i++) {" line55="            receive[i] = pins.spiWrite(transmit[i]);" line56="        }" line57="        pins.digitalWritePin(chipSelect, 1)" line58="" line59="        // deal with bit-order" line60="        receive = rbuffer(receive)" line61="" line62="        return receive" line63="    }" line64="" line65="    export enum PS2Button {" line66="        Select," line67="        Start," line68="        Up," line69="        Down," line70="        L1," line71="        R1," line72="        Left," line73="        Right," line74="        L2," line75="        R2," line76="        Triangle," line77="        Cross," line78="        L3," line79="        R3," line80="        Square," line81="        Circle," line82="        Buttons" line83="    };" line84="" line85="    /**" line86="     * PS2 button pressed" line87="     * @param b ps2 button;" line88="     */" line89="    //% weight=80" line90="    //% block=&quot;button pressed %b&quot;" line91="    //% b.fieldEditor=&quot;gridpicker&quot; b.fieldOptions.columns=4" line92="    export function button_pressed(b: PS2Button): number {" line93="        if (!connected) return 0x00" line94="" line95="        switch (b) {" line96="            case PS2Button.Select:" line97="                return pad[0] &amp; 0x01 ? 0 : 1;" line98="            case PS2Button.L3:" line99="                return pad[0] &amp; 0x02 ? 0 : 1;" line100="            case PS2Button.R3:" line101="                return pad[0] &amp; 0x04 ? 0 : 1;" line102="            case PS2Button.Start:" line103="                return pad[0] &amp; 0x08 ? 0 : 1;" line104="            case PS2Button.Up:" line105="                return pad[0] &amp; 0x10 ? 0 : 1;" line106="            case PS2Button.Right:" line107="                return pad[0] &amp; 0x20 ? 0 : 1;" line108="            case PS2Button.Down:" line109="                return pad[0] &amp; 0x40 ? 0 : 1;" line110="            case PS2Button.Left:" line111="                return pad[0] &amp; 0x80 ? 0 : 1;" line112="            case PS2Button.L2:" line113="                return pad[1] &amp; 0x01 ? 0 : 1;" line114="            case PS2Button.R2:" line115="                return pad[1] &amp; 0x02 ? 0 : 1;" line116="            case PS2Button.L1:" line117="                return pad[1] &amp; 0x04 ? 0 : 1;" line118="            case PS2Button.R1:" line119="                return pad[1] &amp; 0x08 ? 0 : 1;" line120="            case PS2Button.Triangle:" line121="                return pad[1] &amp; 0x10 ? 0 : 1;" line122="            case PS2Button.Circle:" line123="                return pad[1] &amp; 0x20 ? 0 : 1;" line124="            case PS2Button.Cross:" line125="                return pad[1] &amp; 0x40 ? 0 : 1;" line126="            case PS2Button.Square:" line127="                return pad[1] &amp; 0x80 ? 0 : 1;" line128="            case PS2Button.Buttons:" line129="                return ~((pad[1] &lt;&lt; 8) | pad[0]) &amp; 0xffff;" line130="        }" line131="        return 0;" line132="    }" line133="" line134="    // PS2 stick values" line135="    export enum PSS {" line136="        LX," line137="        RX," line138="        LY," line139="        RY" line140="    };" line141="" line142="    /**" line143="    * PS2 stick value" line144="    * @param stick ps2 stick;" line145="    */" line146="    //% weight=70" line147="    //% block=&quot;stick value %stick&quot;" line148="    //% stick.fieldEditor=&quot;gridpicker&quot; stick.fieldOptions.columns=2" line149="    export function stick_value(stick: PSS): number {" line150="        if (!connected) return 0x00" line151="" line152="        switch (stick) {" line153="            case PSS.RX:" line154="                return pad[2] - 0x80;" line155="            case PSS.RY:" line156="                return pad[3] - 0x80;" line157="            case PSS.LX:" line158="                return pad[4] - 0x80;" line159="            case PSS.LY:" line160="                return pad[5] - 0x80;" line161="        }" line162="        return 0;" line163="    }" line164="" line165="    /**" line166="    *  read game pad" line167="    */" line168="    //% weight=90" line169="    //% block=&quot;read Gamepad&quot;" line170="    export function readGamepad(): boolean {" line171="        let buf = send_command(poll_cmd)" line172="        if (buf[2] != 0x5a) {" line173="            return false;" line174="        }" line175="" line176="        for (let j = 0; j &lt; 6; j++) {" line177="            pad[j] = buf[3 + j];" line178="        }" line179="" line180="        connected = true" line181="" line182="        return true" line183="    }" line184="" line185="    // basic.forever(function () {" line186="    //     poll();" line187="    // })" line188="" line189="    // reverse " line190="    //&quot;reverse&quot;: &quot;github:gbraad/pxt-reversebit#v0.1.0&quot;" line191="    const rbits = hex`" line192="    008040C020A060E0109050D030B070F0088848C828A868E8189858D838B878F8" line193="    048444C424A464E4149454D434B474F40C8C4CCC2CAC6CEC1C9C5CDC3CBC7CFC" line194="    028242C222A262E2129252D232B272F20A8A4ACA2AAA6AEA1A9A5ADA3ABA7AFA" line195="    068646C626A666E6169656D636B676F60E8E4ECE2EAE6EEE1E9E5EDE3EBE7EFE" line196="    018141C121A161E1119151D131B171F1098949C929A969E9199959D939B979F9" line197="    058545C525A565E5159555D535B575F50D8D4DCD2DAD6DED1D9D5DDD3DBD7DFD" line198="    038343C323A363E3139353D333B373F30B8B4BCB2BAB6BEB1B9B5BDB3BBB7BFB" line199="    078747C727A767E7179757D737B777F70F8F4FCF2FAF6FEF1F9F5FDF3FBF7FFF`" line200="" line201="    /**" line202="     * Reverse buffer of bits" line203="     * @param b buffer to be reversed" line204="     */" line205="    function rbuffer(b: Buffer): Buffer {" line206="        let output = pins.createBuffer(b.length);" line207="        for (let k = 0; k &lt; b.length; k++) {" line208="            let n = b[k]" line209="            output[k] = rbit(n)" line210="        }" line211="        return output" line212="    }" line213="" line214="    /**" line215="     * Reverse bit" line216="     * @param value to be reversed" line217="     */" line218="    function rbit(value: number): number {" line219="        return rbits[value] || 0x00;" line220="    }" line221="    // }" line222="}" numlines="223"></mutation></block></statement></block></xml>